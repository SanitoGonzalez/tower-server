// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_TYPES_TOWER_WORLD_H_
#define FLATBUFFERS_GENERATED_TYPES_TOWER_WORLD_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

namespace tower {
namespace world {

struct Vector2;

struct Vector2i;

struct TileData;

enum class TileType : uint8_t {
  NONE = 0,
  TERRAIN = 1,
  MIN = NONE,
  MAX = TERRAIN
};

inline const TileType (&EnumValuesTileType())[2] {
  static const TileType values[] = {
    TileType::NONE,
    TileType::TERRAIN
  };
  return values;
}

inline const char * const *EnumNamesTileType() {
  static const char * const names[3] = {
    "NONE",
    "TERRAIN",
    nullptr
  };
  return names;
}

inline const char *EnumNameTileType(TileType e) {
  if (::flatbuffers::IsOutRange(e, TileType::NONE, TileType::TERRAIN)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTileType()[index];
}

enum class TileState : uint8_t {
  NONE = 0,
  BLOCKED = 1,
  MIN = NONE,
  MAX = BLOCKED
};

inline const TileState (&EnumValuesTileState())[2] {
  static const TileState values[] = {
    TileState::NONE,
    TileState::BLOCKED
  };
  return values;
}

inline const char * const *EnumNamesTileState() {
  static const char * const names[3] = {
    "NONE",
    "BLOCKED",
    nullptr
  };
  return names;
}

inline const char *EnumNameTileState(TileState e) {
  if (::flatbuffers::IsOutRange(e, TileState::NONE, TileState::BLOCKED)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTileState()[index];
}

enum class ObjectType : uint16_t {
  NONE = 0,
  MIN = NONE,
  MAX = NONE
};

inline const ObjectType (&EnumValuesObjectType())[1] {
  static const ObjectType values[] = {
    ObjectType::NONE
  };
  return values;
}

inline const char * const *EnumNamesObjectType() {
  static const char * const names[2] = {
    "NONE",
    nullptr
  };
  return names;
}

inline const char *EnumNameObjectType(ObjectType e) {
  if (::flatbuffers::IsOutRange(e, ObjectType::NONE, ObjectType::NONE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesObjectType()[index];
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vector2 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;

 public:
  struct Traits;
  Vector2()
      : x_(0),
        y_(0) {
  }
  Vector2(float _x, float _y)
      : x_(::flatbuffers::EndianScalar(_x)),
        y_(::flatbuffers::EndianScalar(_y)) {
  }
  float x() const {
    return ::flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return ::flatbuffers::EndianScalar(y_);
  }
};
FLATBUFFERS_STRUCT_END(Vector2, 8);

struct Vector2::Traits {
  using type = Vector2;
};

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vector2i FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t x_;
  int32_t y_;

 public:
  struct Traits;
  Vector2i()
      : x_(0),
        y_(0) {
  }
  Vector2i(int32_t _x, int32_t _y)
      : x_(::flatbuffers::EndianScalar(_x)),
        y_(::flatbuffers::EndianScalar(_y)) {
  }
  int32_t x() const {
    return ::flatbuffers::EndianScalar(x_);
  }
  int32_t y() const {
    return ::flatbuffers::EndianScalar(y_);
  }
};
FLATBUFFERS_STRUCT_END(Vector2i, 8);

struct Vector2i::Traits {
  using type = Vector2i;
};

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1) TileData FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t type_;
  uint8_t state_;

 public:
  struct Traits;
  TileData()
      : type_(0),
        state_(0) {
  }
  TileData(tower::world::TileType _type, tower::world::TileState _state)
      : type_(::flatbuffers::EndianScalar(static_cast<uint8_t>(_type))),
        state_(::flatbuffers::EndianScalar(static_cast<uint8_t>(_state))) {
  }
  tower::world::TileType type() const {
    return static_cast<tower::world::TileType>(::flatbuffers::EndianScalar(type_));
  }
  tower::world::TileState state() const {
    return static_cast<tower::world::TileState>(::flatbuffers::EndianScalar(state_));
  }
};
FLATBUFFERS_STRUCT_END(TileData, 2);

struct TileData::Traits {
  using type = TileData;
};

}  // namespace world
}  // namespace tower

#endif  // FLATBUFFERS_GENERATED_TYPES_TOWER_WORLD_H_
